from __future__ import annotations
from typing import Tuple, Optional
import numpy as np

try:
    import cupy as cp
except Exception as e:
    cp = None


def _roll_diff_forward(x, axis: int, h: float):
    out = (cp.roll(x, -1, axis=axis) - x) / h
    slicer = [slice(None)] * x.ndim
    slicer[axis] = -1
    out[tuple(slicer)] = 0.0
    return out


def _roll_diff_backward(x, axis: int, h: float):
    out = (x - cp.roll(x, 1, axis=axis)) / h
    slicer = [slice(None)] * x.ndim
    slicer[axis] = 0
    out[tuple(slicer)] = 0.0
    return out


def upwind_gradient(phi, spacing: Tuple[float, ...], speed):
    grads = []
    for ax, h in enumerate(spacing):
        Dp = _roll_diff_forward(phi, ax, h)
        Dm = _roll_diff_backward(phi, ax, h)
        g = cp.where(speed >= 0.0, Dm, Dp)
        grads.append(g)
    return tuple(grads)


def anisotropic_norm(gx, gy, gz, nx, ny, nz, a_parallel: float, a_perp: float):
    g2 = gx * gx + gy * gy + gz * gz
    gdotn = gx * nx + gy * ny + gz * nz
    return cp.sqrt(cp.maximum(0.0, a_perp * g2 + (a_parallel - a_perp) * gdotn * gdotn) + 1e-12)


def reinitialize(phi, spacing: Tuple[float, ...], iters: int = 20, dtau: float = 0.2):
    eps = 1.0
    sgn = phi / cp.sqrt(phi * phi + eps)

 
    for _ in range(iters):
        Dxp = _roll_diff_forward(phi, 0, spacing[0])
        Dxm = _roll_diff_backward(phi, 0, spacing[0])

        if phi.ndim >= 2:
            Dyp = _roll_diff_forward(phi, 1, spacing[1])
            Dym = _roll_diff_backward(phi, 1, spacing[1])
        else:
            Dyp = Dym = 0.0

        if phi.ndim == 3:
            Dzp = _roll_diff_forward(phi, 2, spacing[2])
            Dzm = _roll_diff_backward(phi, 2, spacing[2])
        else:
            Dzp = Dzm = 0.0

        a_plus = cp.sqrt(
            cp.maximum(Dxm, 0) ** 2 + cp.minimum(Dxp, 0) ** 2
            + (cp.maximum(Dym, 0) ** 2 + cp.minimum(Dyp, 0) ** 2 if phi.ndim >= 2 else 0)
            + (cp.maximum(Dzm, 0) ** 2 + cp.minimum(Dzp, 0) ** 2 if phi.ndim == 3 else 0)
        )
        a_minus = cp.sqrt(
            cp.maximum(Dxp, 0) ** 2 + cp.minimum(Dxm, 0) ** 2
            + (cp.maximum(Dyp, 0) ** 2 + cp.minimum(Dym, 0) ** 2 if phi.ndim >= 2 else 0)
            + (cp.maximum(Dzp, 0) ** 2 + cp.minimum(Dzm, 0) ** 2 if phi.ndim == 3 else 0)
        )

        grad_norm = cp.where(sgn >= 0, a_plus, a_minus)
        phi = phi - dtau * (cp.sign(sgn) * (grad_norm - 1.0))

    return phi


def evolve_level_set_gpu(
    phi0_cpu: np.ndarray,              # preload tumor SDF（CPU numpy）
    d_brain_cpu: np.ndarray,           # preload brain distance-to-boundary（CPU numpy）
    nx_cpu: np.ndarray, ny_cpu: np.ndarray, nz_cpu: np.ndarray,  # preload normals（CPU numpy）
    spacing: Tuple[float, ...],
    t_final: float,
    v0: float = 0.25,
    alpha: float = 0.9,
    sigma_mm: float = 6.0,
    a_parallel: float = 1.0,
    a_perp: float = 0.2,
    cfl: float = 0.9,
    reinit_every: Optional[int] = 15,
):
    if cp is None:
        raise RuntimeError("CuPy is not available. Please install cupy-cuda11x/12x.")

    spacing = tuple(float(s) for s in spacing)

    # ---- move to GPU once ----
    phi = cp.asarray(phi0_cpu, dtype=cp.float32)
    d_brain = cp.asarray(d_brain_cpu, dtype=cp.float32)
    nx = cp.asarray(nx_cpu, dtype=cp.float32)
    ny = cp.asarray(ny_cpu, dtype=cp.float32)
    nz = cp.asarray(nz_cpu, dtype=cp.float32)

    # opposition field from precomputed distance
    P = (1.0 - cp.exp(-d_brain / float(sigma_mm))).astype(cp.float32)

    t = 0.0
    step = 0
    while t < t_final - 1e-12:
        speed = (v0 - alpha * P).astype(cp.float32)

        max_speed = float(cp.max(cp.abs(speed)).get())
        if max_speed < 1e-12:
            break

        dt = cfl * min(spacing) / (np.sqrt(a_parallel) * max_speed)
        if t + dt > t_final:
            dt = t_final - t

        gx, gy, gz = upwind_gradient(phi, spacing, speed)
        if phi.ndim == 2:
            gz = 0.0

        grad_norm = anisotropic_norm(gx, gy, gz, nx, ny, nz, a_parallel, a_perp)
        phi = phi - dt * speed * grad_norm

        step += 1
        if reinit_every and (step % reinit_every == 0):
            phi = reinitialize(phi, spacing, iters=20, dtau=0.2)

        t += dt

    S1 = (phi <= 0).astype(cp.uint8)
    return cp.asnumpy(phi), cp.asnumpy(S1)
